*** Interfaces
- Use class first, change to interface when refactor.
- Do not use interface for enum, java has enum
- Complete decoupling method by using interface as arguments and result.
**** CompositionVsInheritance
#+BEGIN_SRC plantuml :file compositionVsInheritance.png
scale 1800*900
car *-- engine
shape <|-- circle
shape <|-- rectangle

plate <|-- dinnerPlate
utensil <|-- spoon
utensil <|-- fork
utensil <|-- knife
custom <|-- placeSetting
placeSetting *-- spoon
placeSetting *-- fork
placeSetting *-- knife
placeSetting *-- dinnerplate
#+END_SRC

#+RESULTS:
[[file:compositionVsInheritance.png]]

**** Adapter pattern
Adapter is used to transform one class to another class to make it adapt to a specific API. In following example, ApplyProcessor.process only take Processor as input. However, what we have is a Filter, which doesn't extend Processor. So we need a FilterAdapter to transform Filter into a Processor.
#+BEGIN_SRC plantuml :file adapter.png
  ApplyProcessor *-- Processor
  Processor <|-- FilterAdapter
  FilterAdapter *-- Filter
  class ApplyProcessor {
  Void process(Processor)
  }
  class Processor {
  String name()
  Object process()
  }
  class FilterAdapter {
  FilterAdapter(Filter)
  }
  class Filter {
  String name()
  WaveForm process()
  }
#+END_SRC

#+RESULTS:
[[file:adapter.png]]

The usage of FilterAdapter is like this

#+BEGIN_SRC java
  ApplyProcessor.process(new FilterAdapter(filter));
#+END_SRC
**** TODO Factory pattern
Factory pattern is a good choice to return a implementation of a interface or an abstract class. In following example, Service users could just take ServiceFactory as input and let ServiceFactory decide which Service is used. *It seems like that we could also take service as input, than pass in different ServiceImpl. Why we are borthered to add an extra factory layer?*
#+BEGIN_SRC plantuml :file factory.png
  ServiceFactory <|.. ServiceFactoryImpl
  ServiceFactoryImpl *-- ServiceImpl
  Service <|.. ServiceImpl
  interface Service {

  }

  class ServiceImpl {
  }

  interface ServiceFactory {
    Service getService()
  }

  class ServiceFactoryImpl {

  }
#+END_SRC

#+RESULTS:
[[file:factory.png]]

*** Inner classes
- Every inner class needs an reference to the enclosing class. It means when you create an inner class, you also create an enclosing class.
- To create a new inner class, you need to creat enclosing class first.
- Innter class is a Object-oriented closure, which hold all information of enclosing class.
**** New innner class
#+BEGIN_SRC java
  public class DotNew {
      public class Inner {}
      public static void main(String[] args) {
          DotNew dotNew = new DotNew();
          DotNew.Inner inner = dotNew.new Inner();
      }
  }
#+END_SRC

**** Nested classes
Inner class + static

**** TODO Closure & callbacks

*** Type Information
**** Class method extractor using Reflection
#+HEADERS: :classname ShowMethods
#+BEGIN_SRC java :results output :exports both :classname ShowMethods
  import java.lang.reflect.*;
  import java.util.regex.*;

  public class ShowMethods {
      private static String usage = "";
      private static Pattern p = Pattern.compile("\\w+\\.");
      private static void print(String s) {
          System.out.println(s);
      }
      public static void main(String[] args) {
          int lines = 0;
          String className = "ShowMethods"; // "java.lang.String"
          try {
              Class<?> c = Class.forName(className);
              Method[] methods = c.getMethods();
              Constructor[] ctors = c.getConstructors();
              for (Method method : methods) {
                  print(p.matcher(method.toString()).replaceAll(""));
              }

              for(Constructor ctor : ctors) {
                  print(p.matcher(ctor.toString()).replaceAll(""));
              }
              lines = methods.length + ctors.length;
          } catch(ClassNotFoundException e) {
              print("No such class: " + e);
          }
      }
  }
#+END_SRC

#+RESULTS:
#+begin_example
public static void main(String[])
public final void wait(long,int) throws InterruptedException
public final native void wait(long) throws InterruptedException
public final void wait() throws InterruptedException
public boolean equals(Object)
public String toString()
public native int hashCode()
public final native Class getClass()
public final native void notify()
public final native void notifyAll()
public ShowMethods()
#+end_example

**** Proxy Pattern
Proxy inserts an extra layer between the consumer and the *real* object.
#+BEGIN_SRC plantuml :file proxy_pattern.png
  interface Interface {
    doSomething()
    somethingElse()
  }

  class RealObject {
  }

  class SimpleProxy {
  }

  class Consumer {
  }

  Interface <|.. RealObject
  Interface <|.. SimpleProxy
  SimpleProxy *-- RealObject
  Consumer *-- SimpleProxy
#+END_SRC

#+RESULTS:
[[file:proxy_pattern.png]]

*** TODO Generics [IMPORTANT]
Java generics use *erasure*, so *List<Integer>* and *List<String>* are both *List* at runtime.
**** C++ vs Java
#+BEGIN_SRC C++
  #include <iostream>
  using namespace std;

  template<class T> class Manipulator {
    T obj;
  public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }
  };

  class HasF {
  public:
    void f() { cout << "HasF::f()" << endl; }
  };

  int main() {
    HasF hf;
    Manipulator<HasF> manipulator(hf);
    manipulator.manipulate();
  }
#+END_SRC

#+RESULTS:
: HasF::f()

#+BEGIN_SRC java :file HasF.java :classname HasF
  class HasF {
      public void f() {System.out.println("HasF.f()");}
  }

  class Manipulator<T> {
      private T obj;
      public Manipulator(T x) { obj = x; }
      // Error: cannot find symbol: method f():
      public void manipulate() { obj.f(); }
  }

  public class Manipulation {
      public static void main(String[] args) {
          HasF hf = new HasF();
          Manipulator<HasF> manipulator =
              new Manipulator<HasF>(hf);
          manipulator.manipulate();
      }
  }
#+END_SRC

**** Reason of erasure
A comprimise for the backward compitibility. So java's generic types cannot be used in operations that explicitly refer to runtime types, such as casts, instanceof operations, and new expressions.

**** Mixins & Decorator pattern
#+BEGIN_SRC C++
  #include <string>
  #include <ctime>
  #include <iostream>
  using namespace std;

  template<class T> class TimeStamped : public T {
    long timeStamp;
  public:
    TimeStamped() { timeStamp = time(0); }
    long getStamp() { return timeStamp; }
  };

  template<class T> class SerialNumbered : public T {
    long serialNumber;
    static long counter;
  public:
    SerialNumbered() { serialNumber = counter++; }
    long getSerialNumber() { return serialNumber; }
  };

  template<class T> long SerialNumbered<T>::counter = 1;

  class Basic {
    string value;
  public:
    void set(string val) { value = val; }
    string get() { return value; }
  };

  int main() {
    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
    mixin1.set("test string 1");
    mixin2.set("test string 2");
    cout << mixin1.get() << " " << mixin1.getStamp() << " "
         << mixin1.getSerialNumber() << endl;
    cout << mixin2.get() << " " << mixin2.getStamp() << " "
         << mixin2.getSerialNumber() << endl;
  }
#+END_SRC

#+RESULTS:
| test | string | 1 | 1498857612 | 1 |
| test | string | 2 | 1498857612 | 2 |

In Java, we can use Decorator pattern to implement one layer mixin.
#+BEGIN_SRC java :classname Decoration
  import java.util.*;

  class Basic {
      private String value;
      public void set(String val) { value = val; }
      public String get() { return value; }
  }

  class Decorator extends Basic {
      protected Basic basic;
      public Decorator(Basic basic) { this.basic = basic; }
      public void set(String val) { this.basic.set(val); }
      public String get() { return this.basic.get(); }
  }

  class TimeStamped extends Decorator {
      private final long timeStamp;
      public TimeStamped(Basic basic) {
          super(basic);
          timeStamp = new Date().getTime();
      }
      public long getTimeStamp() { return timeStamp; }
  }

  public class Decoration {
      public static void main(String[] args) {
          TimeStamped t = new TimeStamped(new Basic());
          System.out.println("time stamp = " + t.getTimeStamp());
      }
  }
#+END_SRC

#+RESULTS:
: time stamp = 1498858194934

**** Latent typing / duck typing
Not related to static or dynamic type checking. Both Python and C++ support it, but not java.

#+BEGIN_SRC python :results output
  class Dog:
      def speak(self):
          print "Arf!"
      def sit(self):
          print "Sitting!"
      def reproduce():
          pass

  class Robot:
      def speak(self):
          print "Click!"
      def sit(self):
          print "Clank!"
      def oilChange(self):
          pass

  def perform(anything):
      anything.speak()
      anything.sit()

  a = Dog()
  b = Robot()
  perform(a)
  perform(b)
#+END_SRC

#+RESULTS:
: Arf!
: Sitting!
: Click!
: Clank!

#+BEGIN_SRC C++
  #include <iostream>
  using namespace std;

  class Dog {
  public:
    void speak() { cout << "Arf!" << endl; }
    void sit() { cout << "Sitting!" << endl; }
    void reproduce() {}
  };

  class Robot {
  public:
    void speak() { cout << "Click!" << endl; }
    void sit() { cout << "Clank!" << endl; }
    void oilChange() {}
  };

  template<class T> void perform(T anything) {
    anything.speak();
    anything.sit();
  }

  int main() {
    Dog d;
    Robot r;
    perform(d);
    perform(r);
  }
#+END_SRC

#+RESULTS:
| Arf!     |
| Sitting! |
| Click!   |
| Clank!   |

