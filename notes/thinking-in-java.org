*** Interfaces
- Use class first, change to interface when refactor.
- Do not use interface for enum, java has enum
- Complete decoupling method by using interface as arguments and result.
**** CompositionVsInheritance
#+BEGIN_SRC plantuml :file compositionVsInheritance.png
scale 1800*900
car *-- engine
shape <|-- circle
shape <|-- rectangle

plate <|-- dinnerPlate
utensil <|-- spoon
utensil <|-- fork
utensil <|-- knife
custom <|-- placeSetting
placeSetting *-- spoon
placeSetting *-- fork
placeSetting *-- knife
placeSetting *-- dinnerplate
#+END_SRC

#+RESULTS:
[[file:compositionVsInheritance.png]]

**** Adapter pattern
Adapter is used to transform one class to another class to make it adapt to a specific API. In following example, ApplyProcessor.process only take Processor as input. However, what we have is a Filter, which doesn't extend Processor. So we need a FilterAdapter to transform Filter into a Processor.
#+BEGIN_SRC plantuml :file adapter.png
  ApplyProcessor *-- Processor
  Processor <|-- FilterAdapter
  FilterAdapter *-- Filter
  class ApplyProcessor {
  Void process(Processor)
  }
  class Processor {
  String name()
  Object process()
  }
  class FilterAdapter {
  FilterAdapter(Filter)
  }
  class Filter {
  String name()
  WaveForm process()
  }
#+END_SRC

#+RESULTS:
[[file:adapter.png]]

The usage of FilterAdapter is like this

#+BEGIN_SRC java
  ApplyProcessor.process(new FilterAdapter(filter));
#+END_SRC
**** TODO Factory pattern
Factory pattern is a good choice to return a implementation of a interface or an abstract class. In following example, Service users could just take ServiceFactory as input and let ServiceFactory decide which Service is used. *It seems like that we could also take service as input, than pass in different ServiceImpl. Why we are borthered to add an extra factory layer?*
#+BEGIN_SRC plantuml :file factory.png
  ServiceFactory <|.. ServiceFactoryImpl
  ServiceFactoryImpl *-- ServiceImpl
  Service <|.. ServiceImpl
  interface Service {

  }

  class ServiceImpl {
  }

  interface ServiceFactory {
    Service getService()
  }

  class ServiceFactoryImpl {

  }
#+END_SRC

#+RESULTS:
[[file:factory.png]]

*** Inner classes
- Every inner class needs an reference to the enclosing class. It means when you create an inner class, you also create an enclosing class.
- To create a new inner class, you need to creat enclosing class first.
- Innter class is a Object-oriented closure, which hold all information of enclosing class.
**** New innner class
#+BEGIN_SRC java
  public class DotNew {
      public class Inner {}
      public static void main(String[] args) {
          DotNew dotNew = new DotNew();
          DotNew.Inner inner = dotNew.new Inner();
      }
  }
#+END_SRC

**** Nested classes
Inner class + static

**** TODO Closure & callbacks

*** Type Information
#+HEADERS: :classname ShowMethods
#+BEGIN_SRC java :results output :exports both :classname ShowMethods
  import java.lang.reflect.*;
  import java.util.regex.*;

  public class ShowMethods {
      private static String usage = "";
      private static Pattern p = Pattern.compile("\\w+\\.");
      private static void print(String s) {
          System.out.println(s);
      }
      public static void main(String[] args) {
          int lines = 0;
          try {
              Class<?> c = Class.forName("ShowMethods");
              Method[] methods = c.getMethods();
              Constructor[] ctors = c.getConstructors();
              for (Method method : methods) {
                  print(p.matcher(method.toString()).replaceAll(""));
              }

              for(Constructor ctor : ctors) {
                  print(p.matcher(ctor.toString()).replaceAll(""));
              }
              lines = methods.length + ctors.length;
          } catch(ClassNotFoundException e) {
              print("No such class: " + e);
          }
      }
  }
#+END_SRC

#+RESULTS:
#+begin_example
Test
public static void main(String[])
public final void wait(long,int) throws InterruptedException
public final native void wait(long) throws InterruptedException
public final void wait() throws InterruptedException
public boolean equals(Object)
public String toString()
public native int hashCode()
public final native Class getClass()
public final native void notify()
public final native void notifyAll()
public ShowMethods()
#+end_example

