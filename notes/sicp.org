** Building Abstractions with Procedures
*** The elements of programming
- Ways provided by programming language to combine simple ideas into complex one
  - primitive expressions
  - means of combination
  - means of abstraction
- expressions
- Naming and the Environment
*** Exercise 1.6
Applicative-order evaluation vs. normal-order evaluation.
function *new-if* use applicative-order, so it will cause maximum recursion depth exceeded, like 1.5.

*** Exercise 1.7
#+BEGIN_SRC scheme :results both
  (define (sqrt-iter guess old-guess x)
    (if (good-enough? guess old-guess)
        guess
        (sqrt-iter (improve guess x)
                   guess
                   x)))

  (define (square x)
    (* x x))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (average x y)
    (/ (+ x y) 2))

  (define (good-enough? guess old-guess)
    (< (abs (- guess old-guess)) 0.001))

  (define (sqrt x)
    (sqrt-iter 1.0 0.0 x))

  (sqrt 10000000000000)
#+END_SRC

#+RESULTS:
: 3162277.6601683795

*** Exercise 1.8
#+BEGIN_SRC scheme :results both
  (define (sqrt-iter guess old-guess x)
    (if (good-enough? guess old-guess)
        guess
        (sqrt-iter (improve guess x)
                   guess
                   x)))

  (define (square x)
    (* x x))

  (define (improve guess x)
    (/ (+ (/ x (square guess)) (+ guess guess)) 3))

  (define (average x y)
    (/ (+ x y) 2))

  (define (good-enough? guess old-guess)
    (< (abs (- guess old-guess)) 0.001))

  (define (sqrt x)
    (sqrt-iter 1.0 0.0 x))

  (sqrt 1000)
#+END_SRC

#+RESULTS:
: 10.000000000000002

*** Exercise 1.9
The first procedure is recursive; the second procedure is iterative.

*** Exercise 1.10 :HARD:
#+BEGIN_SRC scheme :results both
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
  ;;; (A 1 10) => 1024
  ;;; (A 2 4) => 65536
  ;;; (A 3 3) => 65536

  (define (f n) (A 0 n)) ;;; f(x) = 2*x
  (define (g n) (A 1 n)) ;;; g(x) = 2^{n}
  (define (h n) (A 2 n)) ;;; h(x) = 2^2^...(n-1 times)
  (define (k n) (* 5 n n))

  (h 4)
#+END_SRC

#+RESULTS:
: 65536

*** Exercise 1.11
#+BEGIN_SRC scheme :results both
  (define (recursive n)
    (if (< n 3)
        n
        (+ (recursive (- n 1))
           (* 2 (recursive (- n 2))) 
           (* 3 (recursive (- n 3))))))

  (define (iterative-inner a b c n)
    (if (< n 3)
        c
        (iterative-inner b c (+ (* 3 a) (* 2 b) c) (- n 1))))
  (define (iterative n)
    (if (< n 1)
        n
        (iterative-inner 0 1 2 n)))

  (recursive 30)
#+END_SRC

#+RESULTS:
: 61354575194

*** Exercise 1.12
